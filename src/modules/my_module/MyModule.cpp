/****************************************************************************
 *
 *   Copyright (c) 2013-2020 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

#include "MyModule.hpp"

MyModule::MyModule() : ModuleParams(nullptr), WorkItem(MODULE_NAME, px4::wq_configurations::nav_and_controllers)
{
    update_parameters(true);
}

bool MyModule::init()
{
    if(!_sensor_combined_sub.registerCallback())
    {
        PX4_ERR("Sensor combined callback registration failed!");
		return false;
    }

    return true;
}

void MyModule::update_parameters(bool force)
{
    if(_parameter_update_sub.updated() || force)
    {
        parameter_update_s pupdate;
        _parameter_update_sub.copy(&pupdate);

        updateParams();
    }
}

bool MyModule::upload()
{
	if(cnt < 1000)
        cnt++;
    else
        cnt = 0;

    _param_my_acc_x.set(_accel(0));
    _param_my_acc_y.set(_accel(1));
    _param_my_acc_z.set(_accel(2));
    _param_my_counter.set(cnt);
    _param_my_boolean.set(true);

	return true;
}

void MyModule::Run()
{
    if (should_exit())
    {
		_sensor_combined_sub.unregisterCallback();
		exit_and_cleanup();
		return;
	}

    sensor_combined_s sensors;

    if (_sensor_combined_sub.update(&sensors)) 
    {
        if (sensors.accelerometer_timestamp_relative != sensor_combined_s::RELATIVE_TIMESTAMP_INVALID) {
			_accel(0) = sensors.accelerometer_m_s2[0];
			_accel(1) = sensors.accelerometer_m_s2[1];
			_accel(2) = sensors.accelerometer_m_s2[2];

			if (_accel.length() < 0.01f) {
				PX4_ERR("degenerate accel!");
				return;
			}
		}
    }

	if(upload())
	{
		my_topic_s mt = {};
		mt.timestamp = hrt_absolute_time();
		mt.my_acc_x = _param_my_acc_x.get();
		mt.my_acc_y = _param_my_acc_y.get();
		mt.my_acc_z = _param_my_acc_z.get();
		mt.my_counter = _param_my_counter.get();
		mt.my_boolean = _param_my_boolean.get();
		_mt_pub.publish(mt);
	}

}

int MyModule::task_spawn(int argc, char *argv[])
{
	MyModule *instance = new MyModule();

	if (instance)
    {
		_object.store(instance);
		_task_id = task_id_is_work_queue;

		if (instance->init())
        {
			return PX4_OK;
		}
	}
    else
    {
		PX4_ERR("alloc failed");
	}

	delete instance;
	_object.store(nullptr);
	_task_id = -1;

	return PX4_ERROR;
}

int MyModule::custom_command(int argc, char *argv[])
{
	return print_usage("Unknown Command");
}

int MyModule::print_usage(const char *reason)
{
	if (reason)
    {
		PX4_WARN("%s\n", reason);
	}

	PRINT_MODULE_DESCRIPTION(
		R"DESCR_STR(
            ###Description###
            It is a test module. 
            my_module gets the data from accelerometer and writes them in the topic generated by me.
            Also the module increases a parameter up to 1000, then resets the parameter.
            ###Description###
            TEST
        )DESCR_STR");

	PRINT_MODULE_USAGE_NAME("my_module", "template");
	PRINT_MODULE_USAGE_COMMAND("start");
	PRINT_MODULE_USAGE_DEFAULT_COMMANDS();

	return 0;
}

extern "C" __EXPORT int my_module_main(int argc, char *argv[])
{
	return MyModule::main(argc, argv);
}
